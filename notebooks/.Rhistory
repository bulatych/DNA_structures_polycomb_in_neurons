load_polycomb <- function(polycomb_path) {
polycomb <- read.delim(polycomb_path, header = FALSE, stringsAsFactors = FALSE)
colnames(polycomb) <- c("chrom", "start", "end", "gene")
polycomb_gr <- GRanges(
seqnames = Rle(polycomb$chrom),
ranges = IRanges(start = polycomb$start, end = polycomb$end),
gene = polycomb$gene
)
return(polycomb_gr)
}
annotate_overlaps <- function(structure_gr, promoters, polycomb_gr, gtf_df, label = "structure") {
# Step 1: overlaps with promoters
prom_overlap <- findOverlaps(promoters, structure_gr, ignore.strand = TRUE)
intersected_proms <- promoters[queryHits(prom_overlap)]
intersected_structure <- structure_gr[subjectHits(prom_overlap)]
# Step 2: overlaps with polycomb anchors
anchor_overlap <- findOverlaps(intersected_structure, polycomb_gr, ignore.strand = TRUE)
final_structure <- intersected_structure[queryHits(anchor_overlap)]
final_polycomb <- polycomb_gr[subjectHits(anchor_overlap)]
final_proms <- intersected_proms[queryHits(anchor_overlap)]
# Step 3: convert to data.frame
df <- as.data.frame(final_structure) %>%
mutate(start_bed = start - 1) %>%
select(seqnames, start_bed, end, width, strand) %>%
rename(chrom = seqnames, ss_start = start_bed, ss_end = end)
df$prom_seqnames <- as.vector(seqnames(final_proms))
df$prom_start <- start(final_proms)
df$prom_end <- end(final_proms)
df$anchor_seqnames <- as.vector(seqnames(final_polycomb))
df$anchor_start <- start(final_polycomb)
df$anchor_end <- end(final_polycomb)
df$tx_name <- mcols(final_proms)$tx_name
df <- rename(df, transcript_id = tx_name)
tx_gene_map <- gtf_df %>%
filter(type == "transcript") %>%
select(transcript_id, gene_name)
df <- left_join(df, tx_gene_map, by = "transcript_id")
return(df)
}
process_and_save <- function(structure_path, promoters, polycomb_gr, gtf_df, out_name, is_gq = FALSE) {
if (is_gq) {
gr <- import_gq_with_strand(structure_path)
gr_df <- as.data.frame(gr)
gr_df$strand <- as.character(strand(gr))
for (strand_label in c("+", "-")) {
strand_data <- gr_df[gr_df$strand == strand_label, ]
strand_gr <- makeGRangesFromDataFrame(strand_data, keep.extra.columns = TRUE)
annotated_df <- annotate_overlaps(
structure_gr = strand_gr,
promoters = promoters,
polycomb_gr = polycomb_gr,
gtf_df = gtf_df
)
write.csv(annotated_df, paste0(out_name, "_strand_", strand_label, ".csv"), row.names = FALSE)
}
} else {
gr <- import.bed(structure_path)
annotated_df <- annotate_overlaps(gr, promoters, polycomb_gr, gtf_df)
write.csv(annotated_df, paste0(out_name, ".csv"), row.names = FALSE)
}
}
annotate_overlaps <- function(structure_gr, promoters, polycomb_gr, gtf_df,
label = "structure", strand_mode = "ignore") {
# Пересечения с промотерами без учёта цепи
prom_overlap <- findOverlaps(promoters, structure_gr, ignore.strand = TRUE)
intersected_proms <- promoters[queryHits(prom_overlap)]
intersected_structure <- structure_gr[subjectHits(prom_overlap)]
# Фильтрация по стренду (если требуется)
if (strand_mode %in% c("forward", "reverse")) {
same_strand <- as.vector(strand(intersected_proms)) == as.vector(strand(intersected_structure))
if (strand_mode == "forward") {
keep <- same_strand
} else if (strand_mode == "reverse") {
keep <- !same_strand
}
intersected_proms <- intersected_proms[keep]
intersected_structure <- intersected_structure[keep]
}
# Пересечения с анкерными полиКом точками
anchor_overlap <- findOverlaps(intersected_structure, polycomb_gr, ignore.strand = TRUE)
final_structure <- intersected_structure[queryHits(anchor_overlap)]
final_polycomb <- polycomb_gr[subjectHits(anchor_overlap)]
final_proms <- intersected_proms[queryHits(anchor_overlap)]
# Финальный датафрейм
df <- data.frame(
chrom = as.vector(seqnames(final_structure)),
ss_start = start(final_structure) - 1,
ss_end = end(final_structure),
width = width(final_structure),
strand_structure = as.vector(strand(final_structure)),
prom_seqnames = as.vector(seqnames(final_proms)),
strand_promoter = as.vector(strand(final_proms)),
prom_start = start(final_proms),
prom_end = end(final_proms),
anchor_seqnames = as.vector(seqnames(final_polycomb)),
anchor_start = start(final_polycomb),
anchor_end = end(final_polycomb),
transcript_id = mcols(final_proms)$tx_name
)
# Присоединяем названия генов
tx_gene_map <- gtf_df %>%
filter(type == "transcript") %>%
select(transcript_id, gene_name)
df <- left_join(df, tx_gene_map, by = "transcript_id")
return(df)
}
process_and_save <- function(structure_path, promoters, polycomb_gr, gtf_df, out_name, is_gq = FALSE) {
if (is_gq) {
gr <- import_gq_with_strand(structure_path)
gr_df <- as.data.frame(gr)
gr_df$strand <- as.character(strand(gr))
# Для каждого типа ориентации
for (strand_mode in c("forward", "reverse", "ignore")) {
# Преобразуем весь GRanges (весь G4)
gq_gr <- makeGRangesFromDataFrame(gr_df, keep.extra.columns = TRUE)
annotated_df <- annotate_overlaps(
structure_gr = gq_gr,
promoters = promoters,
polycomb_gr = polycomb_gr,
gtf_df = gtf_df,
strand_mode = strand_mode
)
write.csv(annotated_df, paste0(out_name, "_", strand_mode, ".csv"), row.names = FALSE)
}
} else {
# Z-DNA (без учёта цепи)
gr <- import.bed(structure_path)
annotated_df <- annotate_overlaps(
structure_gr = gr,
promoters = promoters,
polycomb_gr = polycomb_gr,
gtf_df = gtf_df,
strand_mode = "ignore"
)
write.csv(annotated_df, paste0(out_name, ".csv"), row.names = FALSE)
}
}
annotate_overlaps <- function(structure_gr, promoters, polycomb_gr, gtf_df, label = "structure") {
# Step 1: overlaps with promoters
prom_overlap <- findOverlaps(promoters, structure_gr, ignore.strand = TRUE)
intersected_proms <- promoters[queryHits(prom_overlap)]
intersected_structure <- structure_gr[subjectHits(prom_overlap)]
# Step 2: overlaps with polycomb anchors
anchor_overlap <- findOverlaps(intersected_structure, polycomb_gr, ignore.strand = TRUE)
final_structure <- intersected_structure[queryHits(anchor_overlap)]
final_polycomb <- polycomb_gr[subjectHits(anchor_overlap)]
final_proms <- intersected_proms[queryHits(anchor_overlap)]
# Step 3: convert to data.frame
df <- as.data.frame(final_structure) %>%
mutate(start_bed = start - 1) %>%
select(seqnames, start_bed, end, width, strand) %>%
rename(chrom = seqnames, ss_start = start_bed, ss_end = end)
df$prom_seqnames <- as.vector(seqnames(final_proms))
df$prom_start <- start(final_proms)
df$prom_end <- end(final_proms)
df$anchor_seqnames <- as.vector(seqnames(final_polycomb))
df$anchor_start <- start(final_polycomb)
df$anchor_end <- end(final_polycomb)
df$tx_name <- mcols(final_proms)$tx_name
df <- rename(df, transcript_id = tx_name)
tx_gene_map <- gtf_df %>%
filter(type == "transcript") %>%
select(transcript_id, gene_name)
df <- left_join(df, tx_gene_map, by = "transcript_id")
return(df)
}
process_and_save <- function(structure_path, promoters, polycomb_gr, gtf_df, out_name, is_gq = FALSE) {
if (is_gq) {
gr <- import_gq_with_strand(structure_path)
gr_df <- as.data.frame(gr)
gr_df$strand <- as.character(strand(gr))
for (strand_label in c("+", "-")) {
strand_data <- gr_df[gr_df$strand == strand_label, ]
strand_gr <- makeGRangesFromDataFrame(strand_data, keep.extra.columns = TRUE)
annotated_df <- annotate_overlaps(
structure_gr = strand_gr,
promoters = promoters,
polycomb_gr = polycomb_gr,
gtf_df = gtf_df
)
write.csv(annotated_df, paste0(out_name, "_strand_", strand_label, ".csv"), row.names = FALSE)
}
} else {
gr <- import.bed(structure_path)
annotated_df <- annotate_overlaps(gr, promoters, polycomb_gr, gtf_df)
write.csv(annotated_df, paste0(out_name, ".csv"), row.names = FALSE)
}
}
annotate_overlaps <- function(structure_gr, promoters, polycomb_gr, gtf_df,
label = "structure", strand_mode = "ignore") {
# Пересечения с промотерами без учёта цепи
prom_overlap <- findOverlaps(promoters, structure_gr, ignore.strand = TRUE)
intersected_proms <- promoters[queryHits(prom_overlap)]
intersected_structure <- structure_gr[subjectHits(prom_overlap)]
# Фильтрация по стренду (если требуется)
if (strand_mode %in% c("forward", "reverse")) {
same_strand <- as.vector(strand(intersected_proms)) == as.vector(strand(intersected_structure))
if (strand_mode == "forward") {
keep <- same_strand
} else if (strand_mode == "reverse") {
keep <- !same_strand
}
intersected_proms <- intersected_proms[keep]
intersected_structure <- intersected_structure[keep]
}
# Пересечения с анкерными полиКом точками
anchor_overlap <- findOverlaps(intersected_structure, polycomb_gr, ignore.strand = TRUE)
final_structure <- intersected_structure[queryHits(anchor_overlap)]
final_polycomb <- polycomb_gr[subjectHits(anchor_overlap)]
final_proms <- intersected_proms[queryHits(anchor_overlap)]
# Финальный датафрейм
df <- data.frame(
chrom = as.vector(seqnames(final_structure)),
ss_start = start(final_structure) - 1,
ss_end = end(final_structure),
width = width(final_structure),
strand_structure = as.vector(strand(final_structure)),
prom_seqnames = as.vector(seqnames(final_proms)),
strand_promoter = as.vector(strand(final_proms)),
prom_start = start(final_proms),
prom_end = end(final_proms),
anchor_seqnames = as.vector(seqnames(final_polycomb)),
anchor_start = start(final_polycomb),
anchor_end = end(final_polycomb),
transcript_id = mcols(final_proms)$tx_name
)
# Присоединяем названия генов
tx_gene_map <- gtf_df %>%
filter(type == "transcript") %>%
select(transcript_id, gene_name)
df <- left_join(df, tx_gene_map, by = "transcript_id")
return(df)
}
process_and_save <- function(structure_path, promoters, polycomb_gr, gtf_df, out_name, is_gq = FALSE) {
if (is_gq) {
gr <- import_gq_with_strand(structure_path)
gr_df <- as.data.frame(gr)
gr_df$strand <- as.character(strand(gr))
# Для каждого типа ориентации
for (strand_mode in c("forward", "reverse", "ignore")) {
# Преобразуем весь GRanges (весь G4)
gq_gr <- makeGRangesFromDataFrame(gr_df, keep.extra.columns = TRUE)
annotated_df <- annotate_overlaps(
structure_gr = gq_gr,
promoters = promoters,
polycomb_gr = polycomb_gr,
gtf_df = gtf_df,
strand_mode = strand_mode
)
write.csv(annotated_df, paste0(out_name, "_", strand_mode, ".csv"), row.names = FALSE)
}
} else {
# Z-DNA (без учёта цепи)
gr <- import.bed(structure_path)
annotated_df <- annotate_overlaps(
structure_gr = gr,
promoters = promoters,
polycomb_gr = polycomb_gr,
gtf_df = gtf_df,
strand_mode = "ignore"
)
write.csv(annotated_df, paste0(out_name, ".csv"), row.names = FALSE)
}
}
# 1. Загрузка данных
gtf_path <- "../data/gencode.v47.chr_patch_hapl_scaff.basic.annotation.gtf.gz"
polycomb_path <- "../data/polycomb_dot_anchors.bed"
txdb_gtf <- load_txdb_and_gtf(gtf_path)
promoters_all <- promoters(txdb_gtf$txdb, upstream = 2000, downstream = 1000)
polycomb_gr <- load_polycomb(polycomb_path)
process_and_save(
structure_path = "../data/GQ_with_strand_HG38.bed",
promoters = promoters_all,
polycomb_gr = polycomb_gr,
gtf_df = txdb_gtf$gtf_df,
out_name = "GQ_in_polycomb",
is_gq = TRUE
)
annotate_overlaps <- function(structure_gr, promoters, polycomb_gr, gtf_df,
label = "structure", strand_mode = "ignore") {
# Пересечения с промотерами без учёта цепи
prom_overlap <- findOverlaps(promoters, structure_gr, ignore.strand = TRUE)
intersected_proms <- promoters[queryHits(prom_overlap)]
intersected_structure <- structure_gr[subjectHits(prom_overlap)]
# Фильтрация по стренду (если требуется)
if (strand_mode %in% c("forward", "reverse")) {
same_strand <- as.vector(strand(intersected_proms)) == as.vector(strand(intersected_structure))
if (strand_mode == "forward") {
keep <- same_strand
} else if (strand_mode == "reverse") {
keep <- !same_strand
}
intersected_proms <- intersected_proms[keep]
intersected_structure <- intersected_structure[keep]
}
# Пересечения с анкерными полиКом точками
anchor_overlap <- findOverlaps(intersected_structure, polycomb_gr, ignore.strand = TRUE)
final_structure <- intersected_structure[queryHits(anchor_overlap)]
final_polycomb <- polycomb_gr[subjectHits(anchor_overlap)]
final_proms <- intersected_proms[queryHits(anchor_overlap)]
# Финальный датафрейм
df <- data.frame(
chrom = as.vector(seqnames(final_structure)),
ss_start = start(final_structure) - 1,
ss_end = end(final_structure),
width = width(final_structure),
strand_structure = as.vector(strand(final_structure)),
prom_seqnames = as.vector(seqnames(final_proms)),
strand_promoter = as.vector(strand(final_proms)),
prom_start = start(final_proms),
prom_end = end(final_proms),
anchor_seqnames = as.vector(seqnames(final_polycomb)),
anchor_start = start(final_polycomb),
anchor_end = end(final_polycomb),
transcript_id = mcols(final_proms)$tx_name
)
# Присоединяем названия генов
tx_gene_map <- gtf_df %>%
filter(type == "transcript") %>%
select(transcript_id, gene_name)
df <- left_join(df, tx_gene_map, by = "transcript_id")
return(df)
}
process_and_save <- function(structure_path, promoters, polycomb_gr, gtf_df, out_name, is_gq = FALSE) {
if (is_gq) {
gr <- import_gq_with_strand(structure_path)
gr_df <- as.data.frame(gr)
gr_df$strand <- as.character(strand(gr))
# Для каждого типа ориентации
for (strand_mode in c("forward", "reverse", "ignore")) {
# Преобразуем весь GRanges (весь G4)
gq_gr <- makeGRangesFromDataFrame(gr_df, keep.extra.columns = TRUE)
annotated_df <- annotate_overlaps(
structure_gr = gq_gr,
promoters = promoters,
polycomb_gr = polycomb_gr,
gtf_df = gtf_df,
strand_mode = strand_mode
)
write.csv(annotated_df, paste0(out_name, "_", strand_mode, ".csv"), row.names = FALSE)
}
} else {
# Z-DNA (без учёта цепи)
gr <- import.bed(structure_path)
annotated_df <- annotate_overlaps(
structure_gr = gr,
promoters = promoters,
polycomb_gr = polycomb_gr,
gtf_df = gtf_df,
strand_mode = "ignore"
)
write.csv(annotated_df, paste0(out_name, ".csv"), row.names = FALSE)
}
}
process_and_save(
structure_path = "../data/GQ_with_strand_HG38.bed",
promoters = promoters_all,
polycomb_gr = polycomb_gr,
gtf_df = txdb_gtf$gtf_df,
out_name = "GQ_in_polycomb",
is_gq = TRUE
)
# 2. Обработка Z-DNA
process_and_save(
structure_path = "../data/HG38_ZDNA_ZDNABERT_predictions_thr_0.25_minlen_6.bed",
promoters = promoters_all,
polycomb_gr = polycomb_gr,
gtf_df = txdb_gtf$gtf_df,
out_name = "Z_DNA_in_polycomb"
)
process_and_save(
structure_path = "../data/GQ_with_strand_HG38.bed",
promoters = promoters_all,
polycomb_gr = polycomb_gr,
gtf_df = txdb_gtf$gtf_df,
out_name = "GQ_in_polycomb",
is_gq = TRUE
)
#' Load TxDb object and GTF as data.frame
#'
#' @param gtf_path Path to GTF file (can be compressed)
#'
#' @return A list with:
#'   - txdb: TxDb object from the GTF
#'   - gtf_df: data.frame with the GTF content
load_txdb_and_gtf <- function(gtf_path) {
txdb <- makeTxDbFromGFF(gtf_path, format = "gtf")
gtf <- import(gtf_path)
gtf_df <- as.data.frame(gtf)
return(list(txdb = txdb, gtf_df = gtf_df))
}
#' Load Polycomb anchor regions as GRanges
#'
#' @param polycomb_path Path to Excel file with polycomb anchors (with columns: chrom, start, end, genes)
#'
#' @return GRanges object with gene metadata
load_polycomb <- function(polycomb_path) {
polycomb <- read.delim(polycomb_path, header = FALSE, stringsAsFactors = FALSE)
colnames(polycomb) <- c("chrom", "start", "end", "gene")
polycomb_gr <- GRanges(
seqnames = Rle(polycomb$chrom),
ranges = IRanges(start = polycomb$start, end = polycomb$end),
gene = polycomb$gene
)
return(polycomb_gr)
}
import_gq_with_strand <- function(path) {
df <- read.delim(path, header = FALSE, stringsAsFactors = FALSE)
# Предположим, что в файле 4 колонки: chr, start, end, strand
colnames(df) <- c("chrom", "start", "end", "strand")
gr <- GRanges(
seqnames = Rle(df$chrom),
ranges = IRanges(start = df$start, end = df$end),  # BED формат: start 0-based
strand = df$strand
)
return(gr)
}
process_and_save(
structure_path = "../data/GQ_with_strand_HG38.bed",
promoters = promoters_all,
polycomb_gr = polycomb_gr,
gtf_df = txdb_gtf$gtf_df,
out_name = "GQ_in_polycomb",
is_gq = TRUE
)
head(read.delim("../data/GQ_with_strand_HG38.bed", header = FALSE))
#' Load TxDb object and GTF as data.frame
#'
#' @param gtf_path Path to GTF file (can be compressed)
#'
#' @return A list with:
#'   - txdb: TxDb object from the GTF
#'   - gtf_df: data.frame with the GTF content
load_txdb_and_gtf <- function(gtf_path) {
txdb <- makeTxDbFromGFF(gtf_path, format = "gtf")
gtf <- import(gtf_path)
gtf_df <- as.data.frame(gtf)
return(list(txdb = txdb, gtf_df = gtf_df))
}
#' Load Polycomb anchor regions as GRanges
#'
#' @param polycomb_path Path to Excel file with polycomb anchors (with columns: chrom, start, end, genes)
#'
#' @return GRanges object with gene metadata
load_polycomb <- function(polycomb_path) {
polycomb <- read.delim(polycomb_path, header = FALSE, stringsAsFactors = FALSE)
colnames(polycomb) <- c("chrom", "start", "end", "gene")
polycomb_gr <- GRanges(
seqnames = Rle(polycomb$chrom),
ranges = IRanges(start = polycomb$start, end = polycomb$end),
gene = polycomb$gene
)
return(polycomb_gr)
}
import_gq_with_strand <- function(path) {
df <- read.delim(path, header = TRUE, stringsAsFactors = FALSE)
# Предположим, что в файле 4 колонки: chr, start, end, strand
colnames(df) <- c("chrom", "start", "end", "strand")
gr <- GRanges(
seqnames = Rle(df$chrom),
ranges = IRanges(start = df$start, end = df$end),  # BED формат: start 0-based
strand = df$strand
)
return(gr)
}
process_and_save(
structure_path = "../data/GQ_with_strand_HG38.bed",
promoters = promoters_all,
polycomb_gr = polycomb_gr,
gtf_df = txdb_gtf$gtf_df,
out_name = "GQ_in_polycomb",
is_gq = TRUE
)
#' Load TxDb object and GTF as data.frame
#'
#' @param gtf_path Path to GTF file (can be compressed)
#'
#' @return A list with:
#'   - txdb: TxDb object from the GTF
#'   - gtf_df: data.frame with the GTF content
load_txdb_and_gtf <- function(gtf_path) {
txdb <- makeTxDbFromGFF(gtf_path, format = "gtf")
gtf <- import(gtf_path)
gtf_df <- as.data.frame(gtf)
return(list(txdb = txdb, gtf_df = gtf_df))
}
#' Load Polycomb anchor regions as GRanges
#'
#' @param polycomb_path Path to Excel file with polycomb anchors (with columns: chrom, start, end, genes)
#'
#' @return GRanges object with gene metadata
load_polycomb <- function(polycomb_path) {
polycomb <- read.delim(polycomb_path, header = FALSE, stringsAsFactors = FALSE)
colnames(polycomb) <- c("chrom", "start", "end", "gene")
polycomb_gr <- GRanges(
seqnames = Rle(polycomb$chrom),
ranges = IRanges(start = polycomb$start, end = polycomb$end),
gene = polycomb$gene
)
return(polycomb_gr)
}
import_gq_with_strand <- function(path) {
df <- read.delim(path, header = TRUE, stringsAsFactors = FALSE)
# Предположим, что в файле 4 колонки: chr, start, end, strand
colnames(df) <- c("chrom", "start", "end", "strand")
gr <- GRanges(
seqnames = Rle(df$chrom),
ranges = IRanges(start = df$start + 1, end = df$end),  # BED формат: start 0-based
strand = df$strand
)
return(gr)
}
